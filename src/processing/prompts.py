"""Anthropic tool definition and prompt builder for email analysis."""

from typing import Any

from src.mcp.types import RawEmail

# Maximum characters of email body sent to Haiku.
# Keeps token costs low while capturing the full content of most emails.
BODY_CHAR_LIMIT = 4_000

# ── Tool definition ────────────────────────────────────────────────────────────

#: Anthropic tool schema for structured email analysis.
#: Haiku is forced to call this tool via tool_choice, guaranteeing
#: a machine-readable response with no JSON parsing fragility.
ANALYSIS_TOOL: dict[str, Any] = {
    "name": "record_email_analysis",
    "description": (
        "Record the structured analysis of an email. "
        "Call this tool with your findings after reading the email."
    ),
    "input_schema": {
        "type": "object",
        "properties": {
            "email_type": {
                "type": "string",
                "enum": ["human", "automated"],
                "description": (
                    "'human': sent by a real person (even a business contact). "
                    "'automated': newsletters, receipts, notifications, marketing, "
                    "alerts, or any message generated by a system rather than a person."
                ),
            },
            "domain": {
                "type": ["string", "null"],
                "enum": [
                    "finance", "shopping", "travel", "health", "government",
                    "work", "education", "newsletter", "marketing", "social",
                    "alerts", "other", None,
                ],
                "description": (
                    "Life-domain category for automated email only. null for human email. "
                    "finance: bills, receipts, bank statements, utilities. "
                    "shopping: orders, shipping, delivery. "
                    "travel: bookings, itineraries, confirmations. "
                    "health: medical, pharmacy, insurance. "
                    "government: official, legal, tax. "
                    "work: HR, IT, internal tools. "
                    "education: courses, certifications, alumni. "
                    "newsletter: subscriptions, digests, editorial. "
                    "marketing: promotions, deals, product announcements. "
                    "social: social media notifications. "
                    "alerts: app alerts, security notices, service updates. "
                    "other: automated but doesn't fit above."
                ),
            },
            "entities": {
                "type": "array",
                "items": {"type": "string"},
                "description": (
                    "Notable named entities: people, organisations, projects, "
                    "products, or key topics mentioned in the email."
                ),
            },
            "summary": {
                "type": "string",
                "description": "One concise sentence summarising the email.",
            },
            "requires_reply": {
                "type": "boolean",
                "description": "True if the sender expects a reply or response.",
            },
            "deadline": {
                "type": ["string", "null"],
                "description": (
                    "Any deadline or time constraint mentioned, e.g. 'by Friday'. "
                    "null if none."
                ),
            },
        },
        "required": [
            "email_type",
            "domain",
            "entities",
            "summary",
            "requires_reply",
            "deadline",
        ],
    },
}


# ── Prompt builder ─────────────────────────────────────────────────────────────


def build_messages(email: RawEmail) -> list[dict[str, str]]:
    """Build the Anthropic messages list for analysing a single email.

    The body is truncated to BODY_CHAR_LIMIT characters.  If no body is
    available (e.g. headers-only from a lightweight search result) the
    snippet is used as a fallback.
    """
    raw_body = email.body or email.snippet or ""
    body_preview = raw_body[:BODY_CHAR_LIMIT]
    truncated = len(raw_body) > BODY_CHAR_LIMIT

    content_lines = [
        f"From: {email.sender}",
        f"Subject: {email.subject}",
    ]
    if email.recipient:
        content_lines.append(f"To: {email.recipient}")
    if email.date:
        content_lines.append(f"Date: {email.date}")

    content_lines.append("")  # blank line before body
    content_lines.append(body_preview)
    if truncated:
        content_lines.append("\n[… email truncated …]")

    return [
        {
            "role": "user",
            "content": (
                "Analyse the following email and call record_email_analysis "
                "with your findings.\n\n" + "\n".join(content_lines)
            ),
        }
    ]
